/** Copyright (c) 2014 Samsung Electronics Co., Ltd. All rights reserved.  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that  * the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice,  *       this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright notice,  *       this list of conditions and the following disclaimer in the documentation and/or  *       other materials provided with the distribution.  *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its contributors may be used to endorse or  *       promote products derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.sdk.accessory.example.galleryprovider;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import org.json.JSONException;import org.json.JSONObject;import android.annotation.SuppressLint;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Handler;import android.os.HandlerThread;import android.os.IBinder;import android.os.Looper;import android.os.RemoteException;import android.provider.MediaStore;import android.util.Base64;import android.util.Log;import android.widget.Toast;import com.bladek.gearwallet.R;import com.bladek.gearwallet.datas.Constants;import com.bladek.gearwallet.datas.DBAdapter;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;import com.samsung.android.sdk.accessory.example.galleryhost.IGalleryHostAction;import com.samsung.android.sdk.accessory.example.galleryhost.IGalleryHostCallback;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.FrequenceReqMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.FrequenceRespMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.GalleryHostMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.ImgReqMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.ImgRespMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.TBListReqMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.TBListRespMsg;import com.samsung.android.sdk.accessory.example.galleryprovider.ImageFetchModelImpl.TBModelJson;public class GalleryProviderService extends SAAgent {    public static final int INITIAL_IMAGE_INDEX = -1;    public static final int REASON_OK = 0;    public static final int REASON_BITMAP_ENCODING_FAILURE = 1;    public static final int REASON_IMAGE_ID_INVALID = 2;    public static final int REASON_EOF_IMAGE = 3;    public static final int REASON_DATABASE_ERROR = 4;    public static final String TAG = "GalleryProviderService";        String[] mProjection = {                MediaStore.Images.Media._ID,                MediaStore.Images.Media.DATA, MediaStore.Images.Media.SIZE,                MediaStore.Images.Media.DISPLAY_NAME,                MediaStore.Images.Media.WIDTH, MediaStore.Images.Media.HEIGHT    };    HashMap<Integer, GalleryProviderConnection> mConnectionsMap = null;    String mImgData = "";    List<TBModelJson> mTb = new ArrayList<TBModelJson>();        // XML file provided the info    private static final int GALLERY_CHANNEL_ID = 104;    private SA mAccessory;    private String mResult = "failure";    private int mReason = REASON_IMAGE_ID_INVALID;    private final IBinder mHostBinder = new GalleryHostBinder();    private IGalleryHostCallback mGalleryHostCallback;    private int mKey;        private HandlerThread mThread;    private Looper mLooper;    private Handler mBackgroundHandler;        private DBAdapter mDB = null;    @Override    public void onCreate() {        super.onCreate();        mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            /*             * Your application can not use Samsung Accessory SDK. You application should work smoothly             * without using this SDK, or you may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        }                mThread = new HandlerThread("GearWallet");        mThread.start();        mLooper = mThread.getLooper();        if (mLooper != null) {            mBackgroundHandler = new Handler(mLooper);        } else {            throw new RuntimeException("Could not get Looper from Handler Thread");        }                mDB = DBAdapter.getInstance();    }    @Override    public IBinder onBind(Intent intent) {        return mHostBinder;    }    @Override    public void onLowMemory() {        closeConnection();        super.onLowMemory();    }    @Override    public void onDestroy() {        super.onDestroy();    }    public GalleryProviderService() {        super(TAG, GalleryProviderConnection.class);    }    public boolean closeConnection() {        if (mConnectionsMap != null) {            final List<Integer> listConnections = new ArrayList<Integer>(mConnectionsMap.keySet());            for (final Integer s : listConnections) {                mConnectionsMap.get(s).close();                mConnectionsMap.remove(s);            }        }        return true;    }    @SuppressLint("UseSparseArrays")    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket uThisConnection, int result) {        if (result == CONNECTION_SUCCESS && uThisConnection != null) {            final GalleryProviderConnection myConnection = (GalleryProviderConnection) uThisConnection;            if (mConnectionsMap == null) {                mConnectionsMap = new HashMap<Integer, GalleryProviderConnection>();            }            myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);            mConnectionsMap.put(myConnection.mConnectionId, myConnection);            mKey = myConnection.mConnectionId;            Toast.makeText(getBaseContext(), R.string.ConnectionEstablishedMsg, Toast.LENGTH_LONG).show();        }    }    @Override    protected void onFindPeerAgentResponse(SAPeerAgent peerAgent, int result) {    }    @Override    protected void onPeerAgentUpdated(SAPeerAgent peerAgent, int result) {    }    @Override    protected void onError(SAPeerAgent peerAgent, String error, int errorCode) {        Log.e(TAG, "ERROR: " + errorCode + ": " + error);    }    private boolean requestThumbNailPush() {        final GalleryHostMsg uRequest = new GalleryHostMsg(Model.THUMBNAIL_PUSH_IND);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRequest.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();            return false;        }        if (mConnectionsMap != null && mConnectionsMap.get(mKey) != null) {            try {                mConnectionsMap.get(mKey).send(GALLERY_CHANNEL_ID,                            uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }        return true;    }    private boolean requestThumbNailNext() {        final GalleryHostMsg uRequest = new GalleryHostMsg(Model.THUMBNAIL_NEXT_IND);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRequest.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();            return false;        }        if (mConnectionsMap != null && mConnectionsMap.get(mKey) != null) {            try {                mConnectionsMap.get(mKey).send(GALLERY_CHANNEL_ID,                            uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }        return true;    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                    || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            /*             * Your application can not use Samsung Accessory SDK. You application should work smoothly             * without using this SDK, or you may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG, "We recommend that you update your Samsung Accessory SDK before using this application.");            ;            return false;        }        return true;    }    private void onDataAvailableonChannel(final GalleryProviderConnection connection, final long channelId, final String data) {    	mBackgroundHandler.post(new Runnable() {            @Override            public void run() {            	            	if (data.contains(Model.THUMBNAIL_LIST_REQ)) {                    sendThumbnails(connection, data);                } else if (data.contains(Model.DOWNSCALE_IMG_REQ)) {                    sendDownscaledImage(connection, data);                } else if (data.contains(Model.INCREMNET_FREQUENCY)) {                	Log.e("TEST : ", Model.INCREMNET_FREQUENCY);                	sendFrqReq(connection, data);                }                            }        });            }    private void publishMediaStoreInfo(Cursor imageCursor) {        for (int j = 0; j < imageCursor.getCount(); j++) {            imageCursor.moveToNext();        }        imageCursor.moveToFirst();    }    private boolean pullThumbnails(Cursor imageCursor, String type) {        String data = "";        final long img_id = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media._ID));        final Bitmap bm = MediaStore.Images.Thumbnails.getThumbnail(                    getApplicationContext().getContentResolver(), img_id, MediaStore.Images.Thumbnails.MICRO_KIND, null);                if (bm == null) {            return false;        }                final ByteArrayOutputStream stream = new ByteArrayOutputStream();        bm.compress(Bitmap.CompressFormat.JPEG, 100, stream);        data = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);                try {            stream.close();        } catch (final IOException e) {            e.printStackTrace();        }                final long img_size = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));        final String name = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));        final int width = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.WIDTH));        final int height = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.HEIGHT));        String color = "";                switch (type) {			case "pointcard" :				Cursor pointCursor = mDB.getConnection().query(Constants.TABLE_NAMES[Constants.POINT], 														  Constants.COLUMS,														  Constants.COL_NAME + " LIKE '" + name + "'",														  null, null, null, null);								if (pointCursor != null && pointCursor.moveToFirst()) {					color = pointCursor.getString(pointCursor.getColumnIndex(Constants.COL_COLOR));										if (!pointCursor.isClosed()) {						pointCursor.close();					}				}								break;			case "creditcard" :				Cursor creditCursor = mDB.getConnection().query(Constants.TABLE_NAMES[Constants.CREDIT], 														  Constants.COLUMS,														  Constants.COL_NAME + " LIKE '" + name + "'",														  null, null, null, null);				if (creditCursor != null && creditCursor.moveToFirst()) {					color = creditCursor.getString(creditCursor.getColumnIndex(Constants.COL_COLOR));									if (!creditCursor.isClosed()) {						creditCursor.close();					}				}								break;			default : break;		}                final TBModelJson msg = new TBModelJson(img_id, name, data, img_size, width, height, color);                Log.d(TAG, "pullThumbnails : " + img_size);        Log.d(TAG, "pullThumbnails : " + name);        Log.d(TAG, "pullThumbnails : " + width);        Log.d(TAG, "pullThumbnails : " + height);        Log.d(TAG, "pullThumbnails : " + color);                mTb.add(msg);                return true;    }    private void sendThumbnails(GalleryProviderConnection connection, String request) {        boolean ret = true;        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;                if (!mTb.isEmpty()) {            mTb.clear();        }                JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }                final TBListReqMsg uRequest = new TBListReqMsg();                        try {            uRequest.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }                final long id = uRequest.getID();        final String type = uRequest.getType();        synchronized (GalleryProviderService.this) {            if (mGalleryHostCallback != null) {                try {                    mGalleryHostCallback.onMessage(                                "Thumbnails requested from Id:" + id,                                connection.getConnectedPeerAgent().getAppName(),                                connection.getConnectedPeerAgent().getAccessory().getName());                } catch (RemoteException e) {                    Log.w(TAG, "Failed to send message to host:" + e.getMessage());                }            }        }        Cursor imageCursor = null;                switch (type) {	        case "pointcard" :		        	imageCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,	        											 "_data LIKE '" + Constants.POINT_SLOT_PATH + "/%.png" + "'",	        											 null, null);	        		        	break;	        case "creditcard" :	        	imageCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,						 								 "_data LIKE '" + Constants.CREDIT_SLOT_PATH + "/%.png" + "'",						 								 null, null);	        		        	break;	        default : break;	    }                if (imageCursor == null) {            mReason = REASON_DATABASE_ERROR;            sendTbListMsg(connection);            return;        }        imageCursor.moveToFirst();        publishMediaStoreInfo(imageCursor);        if (id != INITIAL_IMAGE_INDEX) {            for (int i = 0; i < imageCursor.getCount(); i++) {                if (id == imageCursor.getInt(imageCursor                            .getColumnIndex(MediaStore.Images.Media._ID))) {                    ret = imageCursor.moveToNext();                    break;                }                if (imageCursor.moveToNext() == false) {                    ret = false;                    break;                }            }        }        final int size = imageCursor.getCount();        if ((ret == true) && (size > 0)) {            do {            	pullThumbnails(imageCursor, type);            } while (imageCursor.moveToNext());                        mResult = "success";            mReason = REASON_OK;        } // check to ignore in case id is last record in DB        else {            mReason = REASON_EOF_IMAGE;        }        if (!imageCursor.isClosed()) {            imageCursor.close();        }        sendTbListMsg(connection);    }    private void sendTbListMsg(GalleryProviderConnection connection) {        final TBListRespMsg uRMessage = new TBListRespMsg(mResult, mReason, mTb.size(), mTb);        String hostMessage;        if ("success".equalsIgnoreCase(mResult)) {            hostMessage = "Sending " + mTb.size() + " thumbnails";        } else {            hostMessage = "Failed to send thumbnails - reason:" + getReason(mReason);        }        synchronized (GalleryProviderService.this) {            if (mGalleryHostCallback != null) {                try {                    mGalleryHostCallback.onMessage(hostMessage, connection.getConnectedPeerAgent().getAppName(),                                connection.getConnectedPeerAgent().getAccessory().getName());                } catch (RemoteException e) {                    Log.w(TAG, "Failed to send message to host:" + e.getMessage());                }            }        }        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRMessage.toJSON().toString();            Log.d(TAG, uJsonStringToSend);        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void sendDownscaledImage(GalleryProviderConnection connection, String request) {        // put a upper cap like say 320x240 for image        mImgData = "";        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int orgWidth = 0, orgHeight = 0;        long orgSize = 0;        String orgName = "";        JSONObject obj = null;                try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final ImgReqMsg uMessage = new ImgReqMsg();        try {            uMessage.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }                final long id = uMessage.getID();        final int width = uMessage.getWidth();        final int height = uMessage.getHeight();        final String type = uMessage.getType();        final String fileName = uMessage.getFileName();        String hostMessage =                    "Downscaled Image requested for image ID:" + id                                + " of Width:" + width + "px Height:" + height + "px";        synchronized (GalleryProviderService.this) {            if (mGalleryHostCallback != null) {                try {                    mGalleryHostCallback.onMessage(                                hostMessage, connection.getConnectedPeerAgent().getAppName(),                                connection.getConnectedPeerAgent().getAccessory().getName());                } catch (RemoteException e) {                    Log.w(TAG, "Failed to send message to host:" + e.getMessage());                }            }        }        Cursor imageCursor = null;                switch (type) {	        case "pointcard" :		        	imageCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,	        											 "_data LIKE '" + Constants.POINT_CARD_PATH + "/" + fileName+ "'",	        											 null, null);	        		        	break;	        case "creditcard" :	        	imageCursor = getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,						 								 "_data LIKE '" + Constants.CREDIT_CARD_PATH + "/" + fileName+ "'",						 								 null, null);	        default	: break;	    }                if (imageCursor != null && imageCursor.moveToFirst()) {            final String path = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DATA));            orgWidth = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.WIDTH));            orgHeight = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.HEIGHT));            orgName = imageCursor.getString(imageCursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));            orgSize = imageCursor.getLong(imageCursor.getColumnIndex(MediaStore.Images.Media.SIZE));            if (!imageCursor.isClosed()) {                imageCursor.close();            }                        pullDownscaledImg(path, width, height);        } else {            mResult = "failure";            mReason = REASON_IMAGE_ID_INVALID;        }                sendImgRsp(connection, id, orgName, orgSize, orgWidth, orgHeight, null);    }    private void sendImgRsp(GalleryProviderConnection connection, long id, String orgName, long orgSize, int orgWidth, int orgHeight, String orgColor) {        final TBModelJson msg = new TBModelJson(id, orgName, mImgData, orgSize, orgWidth, orgHeight, orgColor);        final ImgRespMsg uresponse = new ImgRespMsg(mResult, mReason, msg);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uresponse.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        String hostMessage;        if ("success".equalsIgnoreCase(mResult)) {            hostMessage = "Sending downsclaed image:" + orgName;        } else {            hostMessage = "Sending downscaled image failed. Reason:" + getReason(mReason);        }                synchronized (GalleryProviderService.this) {            if (mGalleryHostCallback != null) {                try {                    mGalleryHostCallback.onMessage(hostMessage, connection.getConnectedPeerAgent().getAppName(),                                				   connection.getConnectedPeerAgent().getAccessory().getName());                } catch (RemoteException e) {                    Log.w(TAG, "Failed to send message to host:" + e.getMessage());                }            }        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void pullDownscaledImg(String path, int width, int height) {        final BitmapFactory.Options opt = new BitmapFactory.Options();        opt.inScaled = false;        opt.inSampleSize = 4; // logic based on original and requested size.        final Bitmap scaledbitmap = Bitmap.createScaledBitmap(BitmapFactory.decodeFile(path, opt), width, height, false);                if (scaledbitmap != null) {            final ByteArrayOutputStream stream = new ByteArrayOutputStream();            scaledbitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);            mImgData = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);            try {                stream.close();            } catch (final IOException e) {                e.printStackTrace();            }        }                mResult = "success"; // success        mReason = REASON_OK; // ok    }        // Test    private void sendFrqReq(GalleryProviderConnection connection, String request) {    	JSONObject obj = null;    	        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }                final FrequenceReqMsg uMessage = new FrequenceReqMsg();                try {            uMessage.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }                final String type = uMessage.getType();        final String name = uMessage.getName();        final int frq = uMessage.getF();	    	    	    switch (type) {			case "pointcard" : 				// Database Update to Point Card				mDB.command(Constants.UPDATE, Constants.POINT, name, null, null, frq);				mDB.command(Constants.DISPLAY, Constants.POINT, null, null, null, 0);								break;			case "creditcard" :				// Database Update to Credit Card				mDB.command(Constants.UPDATE, Constants.CREDIT, name, null, null, frq);				mDB.command(Constants.DISPLAY, Constants.CREDIT, null, null, null, 0);								break;			default : break;		}	        			mResult = "success"; // success        mReason = REASON_OK; // ok    	sendFrqRsp(connection);    }        private void sendFrqRsp(GalleryProviderConnection connection) {    	final FrequenceRespMsg uresponse = new FrequenceRespMsg(mResult, mReason);    	String uJsonStringToSend = "";    	        try {            uJsonStringToSend = uresponse.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }    	        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private String getReason(int errorCode) {        switch (errorCode) {            case REASON_OK:                return "OK";            case REASON_BITMAP_ENCODING_FAILURE:                return "Bitmap Decoding failed";            case REASON_IMAGE_ID_INVALID:                return "Invalid image id";            case REASON_EOF_IMAGE:                return "End of image set";            case REASON_DATABASE_ERROR:                return "Data base error";            default:                return "Unknown error";        }    }    public class LocalBinder extends Binder {        public GalleryProviderService getService() {            return GalleryProviderService.this;        }    }    public class GalleryHostBinder extends IGalleryHostAction.Stub {        @Override        public void registerCallback(IGalleryHostCallback callback) throws RemoteException {            Log.d(TAG, "Host Callback registered");            synchronized (GalleryProviderService.this) {                mGalleryHostCallback = callback;            }        }        @Override        public void disconnect() throws RemoteException {            closeConnection();        }        @Override        public void push() throws RemoteException {            requestThumbNailPush();        }        @Override        public void next() throws RemoteException {            requestThumbNailNext();        }        @Override        public void unregisterCallback() throws RemoteException {            Log.d(TAG, "Host Callback unregistered");            synchronized (GalleryProviderService.this) {                mGalleryHostCallback = null;            }        }    }    public class GalleryProviderConnection extends SASocket {        public static final String TAG = "GalleryProviderConnection";        private int mConnectionId;        public GalleryProviderConnection() {            super(GalleryProviderConnection.class.getName());        }        @Override        public void onReceive(int channelId, byte[] data) {            final String strToUpdateUI = new String(data);            Log.d(TAG, "onReceive() " + strToUpdateUI);            onDataAvailableonChannel(this, channelId, strToUpdateUI);        }        @Override        public void onError(int channelId, String errorString, int error) {        }        @Override        public void onServiceConnectionLost(int errorCode) {            if (mConnectionsMap != null) {                mConnectionsMap.remove(mConnectionId);            }        }    }}